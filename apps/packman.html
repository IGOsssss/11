<html>

<head>
    <title>Packman</title>
</head>

<style>
    .level {
        position: relative;
        border: 2px solid black;
        width: 410px;
        height: 310px;
    }

    .packman {
        position: absolute;
        z-index: 5;
        width: 10px;
        height: 10px;
        background: green;
        box-sizing: border-box;
        border-right: 3px solid black;
    }

    .tail {
        position: absolute;
        z-index: 1;
        width: 10px;
        height: 10px;
        background: yellow;
        opacity: .5;
        border: 1px solid black;
        box-sizing: border-box;
    }

    .wall {
        position: absolute;
        background: red;
    }
</style>

<body>

    <div id="level" class="level">
        <div class="wall" style="top:0px;left:100px;width:40px;height:100px"></div>
        <div class="wall" style="top:140px;left:90px;width:40px;height:20px"></div>
        <div class="wall target" style="top:240px;left:200px;width:40px;height:40px"></div>
    </div>

    <script>
        const level = document.getElementById('level');
        const walls = document.querySelectorAll('.wall');

        const directions = {
            top: 0,
            right: 1,
            bottom: 2,
            left: 3
        }

        function getRectPoints(left, top, width, height) {
            return {
                topLeft: { left, top },
                topRight: { left: left + width, top },
                bottomRight: { left: left + width, top: top + height },
                bottomLeft: { left, top: top + height }
            };
        }

        function getElementBounds(element) {
            const [left, top, width, height] = [
                parseInt(element.style.left),
                parseInt(element.style.top),
                parseInt(element.style.width),
                parseInt(element.style.height)];
            return {
                left,
                top,
                right: left + width,
                bottom: top + height
            };
        }

        const LEVEL_WIDTH = 400;
        const LEVEL_HEIGHT = 300;

        let id = 0;

        class Packman {

            id = id++;
            hostElement = null;
            left = 0;
            top = 0;
            width = 10;
            height = 10;
            currentDirection = directions.right;
            speed = 10;

            constructor() {
                let element = document.createElement('div');
                element.setAttribute('class', 'packman');
                level.appendChild(element);
                this.hostElement = element;
            }

            calculateNextStep() {
                let left = this.left, top = this.top;
                switch (this.currentDirection) {
                    case directions.top:
                        top -= this.speed;
                        break;
                    case directions.right:
                        left += this.speed;
                        break;
                    case directions.bottom:
                        top += this.speed;
                        break;
                    case directions.bottom:
                    default:
                        left -= this.speed;
                        break;
                }
                return { left, top };
            }

            canRun(step) {
                if (step.left < 0) {
                    return false;
                }
                if (step.left > LEVEL_WIDTH) {
                    return false;
                }
                if (step.top > LEVEL_HEIGHT) {
                    return false;
                }
                if (step.top < 0) {
                    return false;
                }

                const futurePosition = getRectPoints(step.left, step.top, this.width, this.height);

                for (const wall of walls) {
                    const wallBounds = getElementBounds(wall);
                    const isPointInsideWall = ({ left, top }) => left > wallBounds.left
                        && top > wallBounds.top
                        && left < wallBounds.right
                        && top < wallBounds.bottom;
                    if (isPointInsideWall(futurePosition.topLeft)) {
                        return wall;
                    }
                    if (isPointInsideWall(futurePosition.topRight)) {
                        return wall;
                    }
                    if (isPointInsideWall(futurePosition.bottomRight)) {
                        return wall;
                    }
                    if (isPointInsideWall(futurePosition.bottomLeft)) {
                        return wall;
                    }
                }

                return true;
            }

            run(steps) {
                for (let i = 0; i < steps; i++) {
                    const nextStep = this.calculateNextStep();
                    const res = this.canRun(nextStep);
                    if (res !== true) {
                        break;
                    }

                    this.tail();
                    this.left = nextStep.left;
                    this.top = nextStep.top;
                }

                this.render();
            }

            runWhileCan() {
                return new Promise((done) => {
                    let steps = 0;
                    const move = () => {
                        this.tail();
                        const nextStep = this.calculateNextStep();
                        const res = this.canRun(nextStep);
                        if (typeof res === 'boolean') {
                            if (res) {
                                this.left = nextStep.left;
                                this.top = nextStep.top;
                                this.render();
                                setTimeout(move, 80);
                            } else {
                                done(steps);
                            }
                        } else if (typeof res === 'object') {
                            console.log(new Array(res.classList));
                            console.log(new Array(res.classList).includes('wall'));
                            done(steps);
                        }
                    };
                    move();
                });
            }

            turnLeft() {
                this.currentDirection = this.currentDirection > 0 ? this.currentDirection - 1 : 3;
                this.render();
            }

            turnRight() {
                this.currentDirection = this.currentDirection < 3 ? this.currentDirection + 1 : 0;
                this.render();
            }

            getStyle() {
                const rotate = this.direction * 90;
                return {
                    left: `${this.left}px`,
                    top: `${this.top}px`,
                    transform: `rotate(${rotate}deg)`
                };
            }

            render() {
                Object.assign(this.hostElement.style, this.getStyle());
            }

            tail() {
                let tail = document.createElement('div');
                tail.setAttribute('class', 'tail');
                Object.assign(tail.style, this.getStyle());
                level.appendChild(tail);
            }

        }

        const packman = new Packman();
        
        packman.run(30);
        packman.turnRight();
        packman.run(11);
        packman.turnLeft();
        packman.run(11);
        packman.turnLeft();
        packman.run(40);

        /*const wrap = (call) => new Promise(done => done(call()));

        const packman = new Packman();
        const bot = () => {
            packman.runWhileCan().then(() => {
                const rnd = Math.round(Math.random() * 4);
                rnd % 2 ? packman.turnRight() : packman.turnLeft();
                bot();
            });
        };
        bot();

        (async () => {
            const packman = new Packman();
            packman.top = 250;
            packman.left = 30;
            await packman.runWhileCan();
            packman.turnRight();
        })();

        (async () => {
            const packman = new Packman();
            packman.top = 150;
            packman.left = 30;
            await packman.runWhileCan();
            packman.turnRight();
        })();

        {
            const packman = new Packman();
            packman.top = 50;

            let total = 0;
            const queue = [];
            queue.push(() => packman.runWhileCan());
            queue.push(steps => {
                total += steps;
                return wrap(() => packman.turnRight());
            });
            queue.push(() => packman.runWhileCan());
            queue.push(() => wrap(() => packman.turnLeft()));
            queue.push(() => packman.runWhileCan());
            queue.push(() => wrap(() => {
                console.log(total);
            }));

            let step = 0;
            const next = (value) => {
                queue[step]().then(result => {
                    if (step < queue.length - 1) {
                        step++;
                        next(result);
                    }
                });
            };
            next();
        }*/

    </script>

</body>


</html>